<?php

namespace Vinelab\NeoEloquent\Query;

use Closure;
use Illuminate\Contracts\Support\Arrayable;
use Illuminate\Database\ConnectionInterface;
use Illuminate\Database\Query\Expression;
use Illuminate\Database\Query\Grammars\Grammar;
use Illuminate\Database\Query\Processors\Processor;
use Illuminate\Support\Arr;
use Illuminate\Support\Str;
use InvalidArgumentException;

use function array_key_exists;
use function array_map;
use function array_merge;
use function array_values;
use function compact;
use function debug_backtrace;
use function func_num_args;
use function is_array;
use function is_bool;
use function is_null;
use function is_string;
use function method_exists;

use const DEBUG_BACKTRACE_PROVIDE_OBJECT;

class Builder extends \Illuminate\Database\Query\Builder
{
    public $relationships = [];

    /**
     * Adds an expression in the where clause to check for the existence of a relationship.
     *
     * The relationship ma y contain the type, as well as a direction. Examples include:
     *  - <MY_TYPE  For a relationship with type "MY_TYPE" pointing from the other to the target node.
     *  - MY_TYPE>  For a relationship with type "MY_TYPE" pointing from the target node to the current one.
     *  - MY_TYPE   For a relationship with type "MY_TYPE" in any direction between the current and target node.
     *  - <         For a relationship with any type pointing from target node to the current node.
     *  - >         For a relationship with any type pointing from the current node to the target node.
     *  -           For a relationship with any type and any direction.
     *
     * The target node will be anonymous if it is null.
     *
     * @param string $relationship The relationship to check.
     * @param string|null $target The name of the target node of the relationship.
     *
     * @return $this
     */
    public function whereRelationship(string $relationship = '', ?string $target = null): self
    {
        $this->wheres[] = [
            'type' => 'Relationship',
            'relationship' => $relationship,
            'target' => $target
        ];

        return $this;
    }

    /**
     * Joins two nodes together based on their relationship in the database.
     *
     * @param string|Closure $target
     * @param string $relationship
     *
     * @return static
     */
    public function joinRelationship(string $target, string $relationship = ''): self
    {
        $this->joins[] = $this->newJoinClause($this, 'cross', $target);

        $this->whereRelationship($relationship, $target);

        return $this;
    }

    /**
     * Adds a relationship if you run the update query.
     *
     * @param string $type The type of the relationship.
     * @param string $direction The direction of the relationship. Can be either '<' or '>' for incoming and outgoing relationships respectively.
     * @param \Illuminate\Database\Query\Builder|null $target The query to determine the find the target(s).
     *
     * @return $this
     */
    public function addRelationship(string $type, string $direction, ?\Illuminate\Database\Query\Builder $target): self
    {
        if ($target) {
            $join = $this->newJoinClause($this, 'cross', $target->from);
            $join->joins = $target->joins;
            $join->wheres = $target->wheres;
            $join->groups = $target->groups;
            $join->havings = $target->havings;
            $this->joins[] = $join;

            $this->relationships[] = [
                'type' => $type,
                'direction' => $direction,
                'target' => $target->from,
            ];
        } else {
            $this->relationships[] = compact('type', 'direction', 'target');
        }

        return $this;
    }

    public function where($column, $operator = null, $value = null, $boolean = 'and')
    {
        if ($column instanceof Expression) {
            $stack = debug_backtrace(DEBUG_BACKTRACE_PROVIDE_OBJECT, 3);
            if (array_key_exists(2, $stack) && $stack[2]['function'] === 'addWhereCountQuery') {
                $query = $stack[2]['args'][0];
                $value = $stack[2]['args'][2];
                $operator = $stack[2]['args'][1];
                $boolean = $stack[2]['args'][3];

                $type = 'Count';

                $this->wheres[] = compact('type', 'query', 'operator', 'value', 'boolean');

                $this->addBinding($query->getBindings(), 'where');

                return $this;
            }
        }
        return parent::where($column, $operator, $value, $boolean); // TODO: Change the autogenerated stub
    }

    public function getBindings(): array
    {
        return Arr::flatten($this->bindings, 1);
    }

    public function addBinding($value, $type = 'where'): Builder
    {
        if (! array_key_exists($type, $this->bindings)) {
            throw new InvalidArgumentException("Invalid binding type: {$type}.");
        }

        $this->bindings[$type][] = $this->castBinding($value);

        return $this;
    }

    public function addWhereCountQuery(self $query,  $operator = '>=', $count = 1, $boolean = 'and'): Builder
    {
        $type = 'count';
        $value = $count;

        $this->wheres[] = compact('type', 'query', 'operator', 'value', 'boolean');

        $this->addBinding($query->getBindings(), 'where');

        return $this;
    }

    public function insert(array $values): bool
    {
        $res = parent::insert($values);
        if (is_bool($res)) {
            return $res;
        }

        // The result might be a summarized result as the connection insert get id hack requires it.
        return true;
    }
}